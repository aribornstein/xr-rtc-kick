<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kick Detector and Visualizer - Receiver</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: white; }
    canvas { display: block; }
    /* Optionally remove UI controls no longer needed */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
    }
    #shareableUrlArea {
      margin-top: 100px; /* Add margin to move it below controls */
      position: relative; /* Ensure proper positioning context */
      padding: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 5px;
      width: fit-content; /* Adjust width to content */
      margin-left: 10px; /* Align with the left edge of the controls */
    }
    textarea, button, label { display: none; }
  </style>
</head>
<body>
  <div id="controls">
    <h2>Receiver (Visualization Only)</h2>
  </div>

  <div id="shareableUrlArea">
    <p><strong>Shareable URL</strong></p>
    <input type="text" id="shareableUrl" readonly />
    <button id="copyUrlButton">Copy URL</button>
  </div>

  <!-- Three.js for stick figure visualization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

  <script>
    let scene, camera, renderer, stickFigure;
    let peerConnection;

    // Initialize Three.js scene
    function initThreeJS() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      renderer = new THREE.WebGLRenderer({antialias: true}); // Enable antialiasing
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff); // Set clear color to white
      document.body.appendChild(renderer.domElement);

      // Create stick figure
      stickFigure = createStickFigure();
      scene.add(stickFigure);

      animate();
    }

    // Create a simple stick figure using lines
    function createStickFigure() {
      const material = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 }); // Make lines thicker

      const head = new THREE.Vector3(0, 1, 0);
      const neck = new THREE.Vector3(0, 0.5, 0);
      const torso = new THREE.Vector3(0, 0, 0);
      const leftLegStart = new THREE.Vector3(0, 0, 0);
      const leftLegEnd = new THREE.Vector3(-0.5, -1, 0);
      const rightLegStart = new THREE.Vector3(0, 0, 0);
      const rightLegEnd = new THREE.Vector3(0.5, -1, 0);
      const leftArmStart = new THREE.Vector3(-0.5, 0.5, 0);
      const leftArmEnd = new THREE.Vector3(-1, 0, 0);
      const rightArmStart = new THREE.Vector3(0.5, 0.5, 0);
      const rightArmEnd = new THREE.Vector3(1, 0, 0);

      const headGeometry = new THREE.SphereGeometry(0.2, 32, 32); // Radius, widthSegments, heightSegments
      const headMaterial = new THREE.MeshBasicMaterial({color: 0x0000ff});
      const headMesh = new THREE.Mesh(headGeometry, headMaterial);
      headMesh.position.set(0, 1, 0); // Position the head

      const headLin = new THREE.BufferGeometry().setFromPoints([head, neck]);
      const torsoGeometry = new THREE.BufferGeometry().setFromPoints([neck, torso]);
      const leftLegGeometry = new THREE.BufferGeometry().setFromPoints([leftLegStart, leftLegEnd]);
      const rightLegGeometry = new THREE.BufferGeometry().setFromPoints([rightLegStart, rightLegEnd]);
      const leftArmGeometry = new THREE.BufferGeometry().setFromPoints([leftArmStart, leftArmEnd]);
      const rightArmGeometry = new THREE.BufferGeometry().setFromPoints([rightArmStart, rightArmEnd]);
      
      const headLine = new THREE.Line(headGeometry, material);
      const torsoLine = new THREE.Line(torsoGeometry, material);
      const leftLeg = new THREE.Line(leftLegGeometry, material);
      const rightLeg = new THREE.Line(rightLegGeometry, material);
      const leftArm = new THREE.Line(leftArmGeometry, material);
      const rightArm = new THREE.Line(rightArmGeometry, material);

      const stickFigureGroup = new THREE.Group();
      stickFigureGroup.add(headMesh); // Add the head mesh
      stickFigureGroup.add(headLin);
      stickFigureGroup.add(torsoLine);
      stickFigureGroup.add(leftLeg);
      stickFigureGroup.add(rightLeg);
      stickFigureGroup.add(leftArm);
      stickFigureGroup.add(rightArm);

      // Store references to the legs for animation
      stickFigureGroup.leftLeg = leftLeg;
      stickFigureGroup.rightLeg = rightLeg;

      return stickFigureGroup;
    }

    // Animate the scene
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // Example function to animate a kick (simulate receiving kick data)
    function simulateKick(direction) {
      const kickRotation = Math.PI / 2; // Define kick rotation amount - Increased to PI/2 for more pronounced kick

      if (direction === "left_kick") {
        stickFigure.leftLeg.rotation.x = kickRotation;
      } else if (direction === "right_kick") {
        stickFigure.rightLeg.rotation.x = -kickRotation;
      }

      // Reset rotation after a short delay
      setTimeout(() => {
        stickFigure.leftLeg.rotation.x = 0;
        stickFigure.rightLeg.rotation.x = 0;
      }, 300); // Shorten the delay for a snappier return
    }

    // // For testing: simulate a left and right kick alternately every 2 seconds
    // setInterval(() => {
    //   simulateKick("left_kick");
    //   setTimeout(() => simulateKick("right_kick"), 1000);
    // }, 2000);

    function decompressSDP(str) {
        try {
            const decodedStr = decodeURIComponent(str); // Fix URL encoding issue
            return JSON.parse(pako.inflate(Uint8Array.from(atob(decodedStr), c => c.charCodeAt(0)), { to: 'string' }));
        } catch (error) {
            console.error("Error decoding SDP:", error);
            return null;
        }
    }

    function compressSDP(desc) {
        const json = JSON.stringify(desc);
        const compressed = pako.deflate(json, { to: 'string' });
        return encodeURIComponent(btoa(String.fromCharCode.apply(null, compressed))); // Ensure URL-safe encoding
    }

    function updateShareableURL(param, value) {
      const url = new URL(window.location.href);
      const pathSegments = url.pathname.split('/');
      const rootDirectory = url.origin + pathSegments.slice(0, pathSegments.length - 1).join('/') + '/';
      const shareableURL = rootDirectory + '?' + param + '=' + value;
      document.getElementById('shareableUrl').value = shareableURL;
    }

    document.getElementById('copyUrlButton').addEventListener('click', function() {
      const shareableUrl = document.getElementById('shareableUrl');
      shareableUrl.select();
      shareableUrl.setSelectionRange(0, 99999); // For mobile devices
      document.execCommand('copy');
      alert('URL copied to clipboard!'); // Optional: provide feedback
    });

    async function initializeReceiver() {
      const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
      peerConnection = new RTCPeerConnection(configuration);

      peerConnection.onicecandidate = e => {
          if (!e.candidate) {
              console.log("ICE gathering complete");
          }
      };

      peerConnection.onconnectionstatechange = () => {
          if (peerConnection.connectionState === 'connected') {
              console.log("âœ… Connection established!");
          }
      };

      peerConnection.ondatachannel = e => {
          const dataChannel = e.channel;
          dataChannel.onopen = () => console.log("Data channel opened (receiver)");
          dataChannel.onmessage = e => {
              console.log("Received kick event: " + e.data);
              simulateKick(e.data); // Call simulateKick with the received data
          };
      };

      // Handle the offer from the URL
      const offer = new URLSearchParams(window.location.search).get('offer');
      if (offer) {
          console.log("ðŸŸ¢ Response mode: Applying offer...");
          const offerDesc = decompressSDP(offer);
          await peerConnection.setRemoteDescription(offerDesc);

          const answerDesc = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answerDesc);

          // Construct the answer URL and display it
          const compressedAnswer = compressSDP(answerDesc);
          const answerUrl = `${window.location.origin}?answer=${compressedAnswer}`;
          updateShareableURL('answer', answerUrl);
          console.log("Answer generated. Share this answer URL:", answerUrl);
      }
    }

    // Initialize Three.js on page load
    window.onload = () => {
      initThreeJS();
      initializeReceiver();
    };
  </script>
</body>
</html>
