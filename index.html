<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Improved Pose & Kick Detection</title>
  <!-- TensorFlow.js and Pose Detection libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background: #f3f3f3;
      font-family: sans-serif;
    }
    #videoContainer {
      position: relative;
      display: inline-block;
    }
    video, canvas {
      width: 640px;
      height: 480px;
      border: 1px solid #aaa;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    #status {
      margin: 10px 0;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Enhanced Kick Detection with MoveNet</h1>
  <p id="status">Initializing...</p>

  <div id="videoContainer">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <script>
    let video, canvas, ctx, detector;
    const statusEl = document.getElementById('status');

    const MIN_ANGLE_DIFF = 0.3;
    const PEAK_DROP_RATIO = 0.8;
    const COOLDOWN_TIME = 300;
    const BASELINE_WINDOW_SIZE = 30;

    const connections = [
      ['nose', 'left_eye'], ['nose', 'right_eye'], ['left_eye', 'left_ear'], 
      ['right_eye', 'right_ear'], ['left_shoulder', 'right_shoulder'],
      ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'],
      ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist'],
      ['left_hip', 'right_hip'], ['left_hip', 'left_knee'], 
      ['left_knee', 'left_ankle'], ['right_hip', 'right_knee'], 
      ['right_knee', 'right_ankle']
    ];

    class FootState {
      constructor() {
        this.state = 'waiting';
        this.baselineDiff = null;
        this.baselineWindow = [];
        this.maxDiff = 0;
        this.cooldown = false;
      }
      updateBaseline(diff) {
        this.baselineWindow.push(diff);
        if (this.baselineWindow.length > BASELINE_WINDOW_SIZE) this.baselineWindow.shift();
        this.baselineDiff = this.baselineWindow.reduce((a,b) => a+b)/this.baselineWindow.length;
      }
      triggerCooldown() {
        this.cooldown = true;
        setTimeout(() => this.cooldown = false, COOLDOWN_TIME);
      }
    }

    const leftFoot = new FootState();
    const rightFoot = new FootState();

    function angleDiff(a, b) {
      let diff = a - b;
      return Math.abs(Math.atan2(Math.sin(diff), Math.cos(diff)));
    }

    function verticalRef(pose) {
      const nose = pose.keypoints.find(k => k.name === 'nose');
      const hips = ['left_hip', 'right_hip'].map(name => pose.keypoints.find(k => k.name === name));
      if (hips.some(kp => kp.score < 0.3) || nose.score < 0.3) return Math.PI / 2;
      const midHip = { x: (hips[0].x + hips[1].x)/2, y: (hips[0].y + hips[1].y)/2 };
      return Math.atan2(midHip.y - nose.y, midHip.x - nose.x);
    }

    function detectKick(foot, hip, ankle, verticalAngle, side) {
      if (hip.score < 0.3 || ankle.score < 0.3 || foot.cooldown) return;
      const legAngle = Math.atan2(ankle.y - hip.y, ankle.x - hip.x);
      const diff = angleDiff(legAngle, verticalAngle);
      if (foot.baselineDiff === null) foot.updateBaseline(diff);

      foot.updateBaseline(diff);

      if (foot.state === 'waiting' && diff > foot.baselineDiff + MIN_ANGLE_DIFF) {
        foot.state = 'extended';
        foot.maxDiff = diff;
      } else if (foot.state === 'extended') {
        if (diff > foot.maxDiff) foot.maxDiff = diff;
        if (diff < foot.maxDiff * PEAK_DROP_RATIO) {
          indicateKick(side);
          foot.triggerCooldown();
          foot.state = 'retracting';
        }
      } else if (foot.state === 'retracting' && diff < foot.baselineDiff + MIN_ANGLE_DIFF / 2) {
        foot.state = 'waiting';
      }
    }

    function indicateKick(side) {
      ctx.fillStyle = 'yellow';
      ctx.font = 'bold 30px Arial';
      ctx.textAlign = side === 'Left' ? 'left' : 'right';
      ctx.textBaseline = 'top';
      ctx.fillText(`${side} Kick!`, side === 'Left' ? 10 : canvas.width - 10, 10);
    }

    function drawSkeleton(kpMap, scaleX, scaleY) {
      ctx.strokeStyle = 'green';
      ctx.lineWidth = 3;
      connections.forEach(([kp1, kp2]) => {
        const keypoint1 = kpMap[kp1];
        const keypoint2 = kpMap[kp2];
        if (keypoint1.score > 0.3 && keypoint2.score > 0.3) {
          ctx.beginPath();
          ctx.moveTo(keypoint1.x * scaleX, keypoint1.y * scaleY);
          ctx.lineTo(keypoint2.x * scaleX, keypoint2.y * scaleY);
          ctx.stroke();
        }
      });
    }

    async function init() {
      video = document.getElementById('video');
      canvas = document.getElementById('overlay');
      ctx = canvas.getContext('2d');
      video.srcObject = await navigator.mediaDevices.getUserMedia({video: true});
      await new Promise(r => video.onloadedmetadata = () => { video.play(); r(); });

      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet);
      statusEl.textContent = 'Detection Started';
      detect();
    }

    async function detect() {
      requestAnimationFrame(detect);
      const poses = await detector.estimatePoses(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (!poses[0]) return;
      const pose = poses[0];
      const kpMap = {};
      pose.keypoints.forEach(kp => { kpMap[kp.name] = kp; });
      const scaleX = canvas.width / video.videoWidth;
      const scaleY = canvas.height / video.videoHeight;
      drawSkeleton(kpMap, scaleX, scaleY);
      const vRef = verticalRef(pose);

      detectKick(leftFoot, kpMap['left_hip'], kpMap['left_ankle'], vRef, 'Left');
      detectKick(rightFoot, kpMap['right_hip'], kpMap['right_ankle'], vRef, 'Right');
    }

    window.onload = init;
  </script>
</body>
</html>