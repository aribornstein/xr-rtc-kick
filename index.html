<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kick Detector - Initiator</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <style>
        #signaling {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #aaa;
        }
        textarea {
            width: 100%;
            margin-bottom: 10px;
        }
        button {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Kick Detector - Initiator</h1>
    <video id="video" playsinline autoplay style="max-width: 100%;"></video>
    <p id="calibrationMessage">Align yourself with the camera.</p>
    <button onclick="startCalibration()">Start Calibration</button>
    <button onclick="startKickDetection()" disabled>Start Game</button>

    <div id="signaling">
        <h2>Manual Signaling (Initiator)</h2>
        <label for="localOffer">Local Offer (send this to Responder):</label>
        <textarea id="localOffer" rows="8" readonly></textarea>
        <br>
        <label for="localICE">Local ICE Candidates (send these to Responder):</label>
        <textarea id="localICE" rows="8" readonly></textarea>
        <br>
        <label for="remoteAnswer">Remote Answer (paste from Responder):</label>
        <textarea id="remoteAnswer" rows="8"></textarea>
        <br>
        <button onclick="setRemoteAnswer()">Set Remote Answer</button>
        <br>
        <label for="remoteICE">Remote ICE Candidates (paste from Responder, one per line):</label>
        <textarea id="remoteICE" rows="8"></textarea>
        <br>
        <button onclick="addRemoteICE()">Add Remote ICE Candidates</button>
    </div>

    <script>
        let detector, video, peerConnection, dataChannel;
        let initialLeftAnkleY, initialRightAnkleY;
        let previousLeftAnkleY, previousRightAnkleY; // Store previous positions
        let kickCooldown = 0; // Cooldown timer

        async function setupVideo(facingMode) {
            video = document.getElementById("video");
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode } });
            video.srcObject = stream;
        }

        async function startCalibration() {
            document.getElementById("calibrationMessage").innerText = "Calibrating...";
            await setupVideo("user"); // Selfie camera

            // Load the MoveNet Lightning model
            const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
            detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);

            const interval = setInterval(async () => {
                const poses = await detector.estimatePoses(video);
                if (poses.length === 0) {
                    document.getElementById("calibrationMessage").innerText = "No person detected.";
                    return;
                }

                const keypoints = poses[0].keypoints;
                const leftAnkle = keypoints.find(k => k.name === 'left_ankle');
                const rightAnkle = keypoints.find(k => k.name === 'right_ankle');
                const nose = keypoints.find(k => k.name === 'nose');

                if (!leftAnkle || !rightAnkle) {
                    document.getElementById("calibrationMessage").innerText = "Step back to fit in frame.";
                } else if (!nose || nose.y > video.videoHeight * 0.6) {
                    document.getElementById("calibrationMessage").innerText = "Raise the phone higher.";
                } else {
                    clearInterval(interval);
                    document.getElementById("calibrationMessage").innerText = "Calibration complete!";
                    document.querySelector("button[onclick='startKickDetection()']").disabled = false;

                    // Store initial ankle positions
                    initialLeftAnkleY = leftAnkle.y;
                    initialRightAnkleY = rightAnkle.y;
                    previousLeftAnkleY = leftAnkle.y; // Initialize previous positions
                    previousRightAnkleY = rightAnkle.y;

                    stopCamera();
                    setupVideo("environment"); // Switch to rear camera
                }

                // Draw keypoints on the video frame
                drawKeypoints(keypoints);
            }, 500);
        }

        function drawKeypoints(keypoints) {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.style.position = 'absolute';
            canvas.style.top = video.offsetTop + 'px';
            canvas.style.left = video.offsetLeft + 'px';
            canvas.style.zIndex = 10; // Ensure it's on top
            video.parentNode.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous drawings


            keypoints.forEach(keypoint => {
                const { x, y, score } = keypoint;
                if (score > 0.5) { // Only draw if confidence is high
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI); // Draw a circle
                    ctx.fillStyle = 'red';
                    ctx.fill();
                }
            });
        }

        function stopCamera() {
            let stream = video.srcObject;
            if (stream) stream.getTracks().forEach(track => track.stop());
        }

        async function startKickDetection() {
            document.getElementById("calibrationMessage").innerText = "Detecting kicks...";

            // Ensure the detector is initialized
            if (!detector) {
                const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
            }

            setupWebRTC();

            setInterval(async () => {
                const poses = await detector.estimatePoses(video);
                if (poses.length === 0) return;

                const keypoints = poses[0].keypoints;
                const leftAnkle = keypoints.find(k => k.name === 'left_ankle');
                const rightAnkle = keypoints.find(k => k.name === 'right_ankle');

                if (!leftAnkle || !rightAnkle) return;

                const kickThresholdPercentage = 0.05; // Adjust as needed (5% of video height)
                const kickThreshold = video.videoHeight * kickThresholdPercentage;
                const downwardVelocityThreshold = 10; // Adjust as needed

                let kick = null;

                if (kickCooldown > 0) {
                    kickCooldown--;
                } else {
                    // Left Kick Detection
                    const leftAnkleVelocity = previousLeftAnkleY - leftAnkle.y; // Positive = Downward
                    if (leftAnkle.y < initialLeftAnkleY - kickThreshold && leftAnkleVelocity > downwardVelocityThreshold) {
                        console.log("Left kick detected");
                        kick = { type: "left_kick", position: leftAnkle };
                        kickCooldown = 10; // 10 frames cooldown
                    }

                    // Right Kick Detection
                    const rightAnkleVelocity = previousRightAnkleY - rightAnkle.y; // Positive = Downward
                    if (rightAnkle.y < initialRightAnkleY - kickThreshold && rightAnkleVelocity > downwardVelocityThreshold) {
                        console.log("Right kick detected");
                        kick = { type: "right_kick", position: rightAnkle };
                        kickCooldown = 10; // 10 frames cooldown
                    }
                }

                if (kick) sendKickData(kick);

                // Update previous ankle positions
                previousLeftAnkleY = leftAnkle.y;
                previousRightAnkleY = rightAnkle.y;
            }, 100);
        }

        function setupWebRTC() {
            peerConnection = new RTCPeerConnection();
            dataChannel = peerConnection.createDataChannel("kickData");

            dataChannel.onopen = () => console.log("WebRTC Data Channel Opened");

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    const localICETextarea = document.getElementById("localICE");
                    localICETextarea.value += JSON.stringify(event.candidate) + "\n";
                    console.log("Local ICE candidate:", event.candidate);
                }
            };

            peerConnection.createOffer().then(offer => {
                return peerConnection.setLocalDescription(offer);
            }).then(() => {
                document.getElementById("localOffer").value = JSON.stringify(peerConnection.localDescription);
                console.log("Local Offer created:", peerConnection.localDescription);
            }).catch(console.error);
        }

        function setRemoteAnswer() {
            const remoteAnswerText = document.getElementById("remoteAnswer").value;
            if (!remoteAnswerText) {
                alert("Please paste the remote answer.");
                return;
            }
            const answer = JSON.parse(remoteAnswerText);
            peerConnection.setRemoteDescription(answer)
                .then(() => console.log("Remote answer set."))
                .catch(console.error);
        }

        function addRemoteICE() {
            const remoteICEText = document.getElementById("remoteICE").value;
            if (!remoteICEText) {
                alert("Please paste remote ICE candidates.");
                return;
            }
            const iceCandidates = remoteICEText.split("\n").filter(candidate => candidate.trim());
            iceCandidates.forEach(candidateStr => {
                const candidate = JSON.parse(candidateStr);
                peerConnection.addIceCandidate(candidate)
                    .then(() => console.log("Added remote ICE candidate:", candidate))
                    .catch(console.error);
            });
        }

        function sendKickData(kick) {
            if (dataChannel.readyState === "open") {
                dataChannel.send(JSON.stringify(kick));
                console.log("Sent kick data:", kick);
            }
        }
    </script>
</body>
</html>
