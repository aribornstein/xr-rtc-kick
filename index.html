<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Improved Pose & Kick Detection</title>
  <!-- TensorFlow.js and Pose Detection libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background: #f3f3f3;
      font-family: sans-serif;
    }
    #videoContainer {
      position: relative;
      display: inline-block;
    }
    video, canvas {
      width: 640px;
      height: 480px;
      border: 1px solid #aaa;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    #status {
      margin: 10px 0;
      font-weight: bold;
    }
    #offer {
      width: 100%;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Enhanced Kick Detection with MoveNet</h1>
  <p id="status">Initializing...</p>

  <div id="videoContainer">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>
  <div>
    <h2>Initiator (Offer)</h2>
    <label for="offer">Offer (copy this to Receiver):</label>
    <textarea id="offer" rows="8" readonly></textarea>
    <br>
    <label for="answer">Answer (paste answer from Receiver here):</label>
    <textarea id="answer" rows="8"></textarea>
    <br>
    <button id="connectButton">Connect with Answer</button>
    <br>
    <label for="iceCandidates">ICE Candidates (paste candidates from Receiver here, one per line):</label>
    <textarea id="iceCandidates" rows="8"></textarea>
  </div>

  <script>
    let video, canvas, ctx, detector;
    const statusEl = document.getElementById('status');

    const MIN_ANGLE_DIFF = 0.3;
    const PEAK_DROP_RATIO = 0.8;
    const COOLDOWN_TIME = 300;
    const BASELINE_WINDOW_SIZE = 30;

    const connections = [
      ['nose', 'left_eye'], ['nose', 'right_eye'], ['left_eye', 'left_ear'], 
      ['right_eye', 'right_ear'], ['left_shoulder', 'right_shoulder'],
      ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'],
      ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist'],
      ['left_hip', 'right_hip'], ['left_hip', 'left_knee'], 
      ['left_knee', 'left_ankle'], ['right_hip', 'right_knee'], 
      ['right_knee', 'right_ankle']
    ];

    class FootState {
      constructor() {
        this.state = 'waiting';
        this.baselineDiff = null;
        this.baselineWindow = [];
        this.maxDiff = 0;
        this.cooldown = false;
      }
      updateBaseline(diff) {
        this.baselineWindow.push(diff);
        if (this.baselineWindow.length > BASELINE_WINDOW_SIZE) this.baselineWindow.shift();
        this.baselineDiff = this.baselineWindow.reduce((a,b) => a+b)/this.baselineWindow.length;
      }
      triggerCooldown() {
        this.cooldown = true;
        setTimeout(() => this.cooldown = false, COOLDOWN_TIME);
      }
    }

    const leftFoot = new FootState();
    const rightFoot = new FootState();

    function angleDiff(a, b) {
      let diff = a - b;
      return Math.abs(Math.atan2(Math.sin(diff), Math.cos(diff)));
    }

    function verticalRef(pose) {
      const nose = pose.keypoints.find(k => k.name === 'nose');
      const hips = ['left_hip', 'right_hip'].map(name => pose.keypoints.find(k => k.name === name));
      if (hips.some(kp => kp.score < 0.3) || nose.score < 0.3) return Math.PI / 2;
      const midHip = { x: (hips[0].x + hips[1].x)/2, y: (hips[0].y + hips[1].y)/2 };
      return Math.atan2(midHip.y - nose.y, midHip.x - nose.x);
    }

    let peerConnection;
    let dataChannel;

    async function createPeerConnection() {
      peerConnection = new RTCPeerConnection();

      dataChannel = peerConnection.createDataChannel("kickDataChannel");
      dataChannel.onopen = () => console.log("Data channel opened");
      dataChannel.onclose = () => console.log("Data channel closed");
      dataChannel.onerror = (error) => console.error("Data channel error:", error);

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log("Local ICE candidate:", event.candidate);
        }
      };

      peerConnection.onicegatheringstatechange = () => {
        console.log(`ICE gathering state changed: ${peerConnection.iceGatheringState}`);
      };

      return peerConnection;
    }

    // Compress the signaling data to a Base36 string.
    function compressSignaling(data) {
        const json = JSON.stringify(data);
        const compressed = LZString.compressToUTF16(json);
        let base36Str = "";
        for (let i = 0; i < compressed.length; i++) {
            const charCode = compressed.charCodeAt(i);
            const base36 = charCode.toString(36).padStart(2, '0'); // Pad to 2 digits
            base36Str += base36;
        }
        return base36Str;
    }

    // Decompress from the Base36 string back to the original object.
    function decompressSignaling(base36Str) {
        let chars = [];
        // Since each char code in UTF16 is encoded to a variable-length base36 string,
        // you'll need a known fixed length. For simplicity assume we pad each code to 2 digits.
        for (let i = 0; i < base36Str.length; i += 2) {
            const code = parseInt(base36Str.substr(i, 2), 36);
            chars.push(String.fromCharCode(code));
        }
        const decompressed = LZString.decompressFromUTF16(chars.join(''));
        return JSON.parse(decompressed);
    }

    async function createOffer() {
      const pc = await createPeerConnection();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      const compressedOffer = compressSignaling(pc.localDescription);
      document.getElementById("offer").value = compressedOffer;
      return pc;
    }

    async function connectWithAnswer() {
      let answerText = document.getElementById("answer").value;
      // If using compression, decompress first
      const answerObj = decompressSignaling(answerText);
      try {
        await peerConnection.setRemoteDescription(answerObj);
        console.log("Remote description set from answer.");
      } catch (e) {
        console.error("Error setting remote description:", e);
        alert("Invalid answer format.");
        return;
      }

      const iceCandidatesText = document.getElementById("iceCandidates").value;

      if (iceCandidatesText) {
        const iceCandidateLines = iceCandidatesText.trim().split('\n');
        for (const line of iceCandidateLines) {
          if (line.trim() === '') continue;
          try {
            const candidate = JSON.parse(line);
            await peerConnection.addIceCandidate(candidate);
            console.log("Added remote ICE candidate:", candidate);
          } catch (e) {
            console.warn("Error adding ICE candidate:", e);
          }
        }
      }
    }

    function sendKick(side) {
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({ type: side === 'Left' ? 'left_kick' : 'right_kick' }));
      } else {
        console.log("Data channel not open, cannot send kick.");
      }
    }

    function detectKick(foot, hip, ankle, verticalAngle, side) {
      if (hip.score < 0.3 || ankle.score < 0.3 || foot.cooldown) return;
      const legAngle = Math.atan2(ankle.y - hip.y, ankle.x - hip.x);
      const diff = angleDiff(legAngle, verticalAngle);
      if (foot.baselineDiff === null) foot.updateBaseline(diff);

      foot.updateBaseline(diff);

      if (foot.state === 'waiting' && diff > foot.baselineDiff + MIN_ANGLE_DIFF) {
        foot.state = 'extended';
        foot.maxDiff = diff;
      } else if (foot.state === 'extended') {
        if (diff > foot.maxDiff) foot.maxDiff = diff;
        if (diff < foot.maxDiff * PEAK_DROP_RATIO) {
          indicateKick(side);
          sendKick(side); // Send kick data over WebRTC
          foot.triggerCooldown();
          foot.state = 'retracting';
        }
      } else if (foot.state === 'retracting' && diff < foot.baselineDiff + MIN_ANGLE_DIFF / 2) {
        foot.state = 'waiting';
      }
    }

    function indicateKick(side) {
      ctx.fillStyle = side === 'Left' ? 'red' : 'blue';
      ctx.font = 'bold 30px Arial';
      ctx.textAlign = side === 'Left' ? 'left' : 'right';
      ctx.textBaseline = 'top';
      ctx.fillText(`${side} Kick!`, side === 'Left' ? 10 : canvas.width - 10, 10);
    }

    function drawSkeleton(pose, scaleX, scaleY) {
      ctx.strokeStyle = 'green';
      ctx.lineWidth = 3;
      connections.forEach(([kp1, kp2]) => {
        const keypoint1 = pose.keypoints.find(kp => kp.name === kp1);
        const keypoint2 = pose.keypoints.find(kp => kp.name === kp2);
        if (keypoint1 && keypoint2 && keypoint1.score > 0.3 && keypoint2.score > 0.3) {
          ctx.beginPath();
          ctx.moveTo(keypoint1.x * scaleX, keypoint1.y * scaleY);
          ctx.lineTo(keypoint2.x * scaleX, keypoint2.y * scaleY);
          ctx.stroke();
        }
      });
    }

    function drawKeypoints(pose, scaleX, scaleY) {
      for (const keypoint of pose.keypoints) {
        if (keypoint.score > 0.3) {
          ctx.font = 'bold 7px Arial';
          ctx.beginPath();
          ctx.arc(keypoint.x * scaleX, keypoint.y * scaleY, 5, 0, 2 * Math.PI);
          ctx.fillStyle = 'red';
          ctx.fill();
          ctx.fillStyle = 'white';
          ctx.fillText(keypoint.name, keypoint.x * scaleX + 6, keypoint.y * scaleY + 2);
        }
      }
    }

    async function init() {
      video = document.getElementById('video');
      canvas = document.getElementById('overlay');
      ctx = canvas.getContext('2d');
      video.srcObject = await navigator.mediaDevices.getUserMedia({video: true});
      await new Promise(r => video.onloadedmetadata = () => { video.play(); r(); });

      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet);
      statusEl.textContent = 'Detection Started';

      // Create offer and start WebRTC
      await createOffer();

      detect();
    }

    async function detect() {
      requestAnimationFrame(detect);
      const poses = await detector.estimatePoses(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (!poses[0]) return;
      const pose = poses[0];
      const kpMap = {};
      pose.keypoints.forEach(kp => { kpMap[kp.name] = kp; });
      const scaleX = canvas.width / video.videoWidth;
      const scaleY = canvas.height / video.videoHeight;
      drawSkeleton(pose, scaleX, scaleY);
      drawKeypoints(pose, scaleX, scaleY);
      const vRef = verticalRef(pose);

      detectKick(leftFoot, kpMap['left_hip'], kpMap['left_ankle'], vRef, 'Left');
      detectKick(rightFoot, kpMap['right_hip'], kpMap['right_ankle'], vRef, 'Right');
    }

    document.getElementById("connectButton").addEventListener("click", connectWithAnswer);
    window.onload = init;
  </script>
</body>
</html>