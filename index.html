<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pose Detection with Kick Detection</title>
  <!-- TensorFlow.js and Pose Detection libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

  <style>
    body {
      margin: 0; 
      padding: 0;
      text-align: center;
      background: #f3f3f3;
      font-family: sans-serif;
    }
    #videoContainer {
      position: relative;
      display: inline-block;
    }
    video, canvas {
      width: 640px;  /* Adjust as you like */
      height: 480px; /* Adjust as you like */
      border: 1px solid #aaa;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    #status {
      margin: 10px 0;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Continuous Pose Detection (MoveNet) + Kick Detection</h1>
  <p id="status">Loading model...</p>

  <div id="videoContainer">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <script>
    let video, canvas, ctx;
    let detector;
    let animationId;

    // -- Kick Detection Globals --
    let previousLeftAnkleY = null;
    let previousRightAnkleY = null;
    let kickCooldownFrames = 0;

    // Constants for thresholds
    const MAX_COOLDOWN = 10;          // frames to wait after a kick is detected
    const KICK_VELOCITY_THRESHOLD = 10; // how quickly the ankle must move up
    const KICK_HEIGHT_THRESHOLD = 0.3;  // fraction of body height foot must rise

    const statusEl = document.getElementById('status');

    // List of edges to connect keypoints into a skeleton
    const connections = [
      ['nose', 'left_eye'], ['nose', 'right_eye'],
      ['left_eye', 'left_ear'], ['right_eye', 'right_ear'],
      ['nose', 'left_shoulder'], ['nose', 'right_shoulder'],
      ['left_shoulder', 'left_elbow'], ['right_shoulder', 'right_elbow'],
      ['left_elbow', 'left_wrist'], ['right_elbow', 'right_wrist'],
      ['left_shoulder', 'right_shoulder'],
      ['left_shoulder', 'left_hip'], ['right_shoulder', 'right_hip'],
      ['left_hip', 'right_hip'],
      ['left_hip', 'left_knee'], ['right_hip', 'right_knee'],
      ['left_knee', 'left_ankle'], ['right_knee', 'right_ankle']
    ];

    async function init() {
      // Grab elements
      video = document.getElementById('video');
      canvas = document.getElementById('overlay');
      ctx = canvas.getContext('2d');

      // 1) Setup camera
      await setupCamera();

      // 2) Create the MoveNet detector
      statusEl.textContent = 'Loading MoveNet model...';
      const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
      statusEl.textContent = 'Model loaded! Starting detection...';

      // 3) Start the detection loop
      detectPose();
    }

    async function setupCamera() {
      // Request webcam
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: 640, height: 480 },
        audio: false
      });
      video.srcObject = stream;

      // Wait for the video to be ready
      return new Promise(resolve => {
        video.onloadedmetadata = () => {
          video.play();
          // Match canvas to video size
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          resolve();
        };
      });
    }

    // -- Kick detection logic --
    function checkForKick(pose) {
      if (kickCooldownFrames > 0) {
        // If we're on cooldown, decrement and return
        kickCooldownFrames--;
        return;
      }

      // Find keypoints we care about
      const leftAnkle = pose.keypoints.find(k => k.name === 'left_ankle');
      const rightAnkle = pose.keypoints.find(k => k.name === 'right_ankle');
      const leftHip   = pose.keypoints.find(k => k.name === 'left_hip');
      const rightHip  = pose.keypoints.find(k => k.name === 'right_hip');

      // Make sure ankles exist & have decent detection confidence
      if (!leftAnkle || !rightAnkle || leftAnkle.score < 0.3 || rightAnkle.score < 0.3) return;

      // For an optional height-based threshold, we need a reference for the body height:
      let bodyHeight = 0;
      if (leftHip && rightHip) {
        if (leftHip.score > 0.3 && rightHip.score > 0.3) {
          const avgHipY = (leftHip.y + rightHip.y) / 2;
          const avgAnkleY = (leftAnkle.y + rightAnkle.y) / 2;
          bodyHeight = Math.abs(avgAnkleY - avgHipY);
        }
      }

      // Current Y positions (lower Y means foot is higher in the image if top=0)
      const currentLeftY = leftAnkle.y;
      const currentRightY = rightAnkle.y;

      // If this is the very first frame, just store the ankles and return
      if (previousLeftAnkleY === null || previousRightAnkleY === null) {
        previousLeftAnkleY = currentLeftY;
        previousRightAnkleY = currentRightY;
        return;
      }

      // Calculate velocity (previous - current). If it's positive => foot moved up
      const leftVelocity = previousLeftAnkleY - currentLeftY;
      const rightVelocity = previousRightAnkleY - currentRightY;

      // Check left foot
      if (leftVelocity > KICK_VELOCITY_THRESHOLD) {
        // Also check if foot is above some fraction of body height
        if (bodyHeight > 0) {
          const footAboveThreshold = (leftHip && leftHip.score > 0.3)
            ? (leftHip.y - leftAnkle.y) > (KICK_HEIGHT_THRESHOLD * bodyHeight)
            : true; // if we canâ€™t measure height, ignore
          if (footAboveThreshold) {
            console.log("Left kick detected!");
            kickCooldownFrames = MAX_COOLDOWN;
          }
        } else {
          console.log("Left kick detected (velocity only)!");
          kickCooldownFrames = MAX_COOLDOWN;
        }
      }

      // Check right foot
      if (rightVelocity > KICK_VELOCITY_THRESHOLD) {
        if (bodyHeight > 0) {
          const footAboveThreshold = (rightHip && rightHip.score > 0.3)
            ? (rightHip.y - rightAnkle.y) > (KICK_HEIGHT_THRESHOLD * bodyHeight)
            : true;
          if (footAboveThreshold) {
            console.log("Right kick detected!");
            kickCooldownFrames = MAX_COOLDOWN;
          }
        } else {
          console.log("Right kick detected (velocity only)!");
          kickCooldownFrames = MAX_COOLDOWN;
        }
      }

      // Update previous ankles for next frame
      previousLeftAnkleY = currentLeftY;
      previousRightAnkleY = currentRightY;
    }

    async function detectPose() {
      // The main detection + draw loop
      animationId = requestAnimationFrame(detectPose);

      if (!detector) return;
      if (video.readyState < 2) return; // not fully playing

      try {
        // Estimate poses
        const poses = await detector.estimatePoses(video);

        // Draw video onto canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // Draw the detected pose(s)
        if (poses && poses.length > 0) {
          drawPoses(poses);

          // Check for kick using the first pose (single-person scenario)
          checkForKick(poses[0]);
        }
      } catch (err) {
        console.error('Pose estimation error:', err);
      }
    }

    function drawPoses(poses) {
      for (const pose of poses) {
        // Draw keypoints
        for (const keypoint of pose.keypoints) {
          if (keypoint.score > 0.3) {
            // Draw a small circle
            ctx.beginPath();
            ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();

            // Optionally label each keypoint
            ctx.fillStyle = 'white';
            ctx.fillText(keypoint.name, keypoint.x + 6, keypoint.y + 2);
          }
        }
        // Draw skeleton
        drawSkeleton(pose);
      }
    }

    function drawSkeleton(pose) {
      // Build a map from name->keypoint
      const kpMap = {};
      pose.keypoints.forEach(kp => {
        kpMap[kp.name] = kp;
      });

      ctx.strokeStyle = 'green';
      ctx.lineWidth = 3;

      // Draw each connection
      for (const [kp1, kp2] of connections) {
        const keypoint1 = kpMap[kp1];
        const keypoint2 = kpMap[kp2];
        if (keypoint1 && keypoint2 &&
            keypoint1.score > 0.3 && keypoint2.score > 0.3) {
          ctx.beginPath();
          ctx.moveTo(keypoint1.x, keypoint1.y);
          ctx.lineTo(keypoint2.x, keypoint2.y);
          ctx.stroke();
        }
      }
    }

    // Initialize on page load
    window.onload = init;
  </script>
</body>
</html>
