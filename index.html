<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Improved Pose & Kick Detection</title>
  <!-- TensorFlow.js and Pose Detection libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background: #f3f3f3;
      font-family: sans-serif;
    }
    #videoContainer {
      position: relative;
      display: inline-block;
    }
    video, canvas {
      width: 640px;
      height: 480px;
      border: 1px solid #aaa;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    #status {
      margin: 10px 0;
      font-weight: bold;
    }
    #offer {
      width: 100%;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Enhanced Kick Detection with MoveNet</h1>
  <p id="status">Initializing...</p>

  <div id="videoContainer">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="shareableUrlArea">
        <p><strong>Shareable URL</strong></p>
        <input type="text" id="shareableUrl" readonly />
        <button id="copyUrlButton">Copy URL</button>
  </div>

  <script>
    let video, canvas, ctx, detector;
    const statusEl = document.getElementById('status');

    const MIN_ANGLE_DIFF = 0.3;
    const PEAK_DROP_RATIO = 0.8;
    const COOLDOWN_TIME = 300;
    const BASELINE_WINDOW_SIZE = 30;

    const connections = [
      ['nose', 'left_eye'], ['nose', 'right_eye'], ['left_eye', 'left_ear'], 
      ['right_eye', 'right_ear'], ['left_shoulder', 'right_shoulder'],
      ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'],
      ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist'],
      ['left_hip', 'right_hip'], ['left_hip', 'left_knee'], 
      ['left_knee', 'left_ankle'], ['right_hip', 'right_knee'], 
      ['right_knee', 'right_ankle']
    ];

    class FootState {
      constructor() {
        this.state = 'waiting';
        this.baselineDiff = null;
        this.baselineWindow = [];
        this.maxDiff = 0;
        this.cooldown = false;
      }
      updateBaseline(diff) {
        this.baselineWindow.push(diff);
        if (this.baselineWindow.length > BASELINE_WINDOW_SIZE) this.baselineWindow.shift();
        this.baselineDiff = this.baselineWindow.reduce((a,b) => a+b)/this.baselineWindow.length;
      }
      triggerCooldown() {
        this.cooldown = true;
        setTimeout(() => this.cooldown = false, COOLDOWN_TIME);
      }
    }

    const leftFoot = new FootState();
    const rightFoot = new FootState();

    function angleDiff(a, b) {
      let diff = a - b;
      return Math.abs(Math.atan2(Math.sin(diff), Math.cos(diff)));
    }

    function verticalRef(pose) {
      const nose = pose.keypoints.find(k => k.name === 'nose');
      const hips = ['left_hip', 'right_hip'].map(name => pose.keypoints.find(k => k.name === name));
      if (hips.some(kp => kp.score < 0.3) || nose.score < 0.3) return Math.PI / 2;
      const midHip = { x: (hips[0].x + hips[1].x)/2, y: (hips[0].y + hips[1].y)/2 };
      return Math.atan2(midHip.y - nose.y, midHip.x - nose.x);
    }

    function detectKick(foot, hip, ankle, verticalAngle, side) {
      if (hip.score < 0.3 || ankle.score < 0.3 || foot.cooldown) return;
      const legAngle = Math.atan2(ankle.y - hip.y, ankle.x - hip.x);
      const diff = angleDiff(legAngle, verticalAngle);
      if (foot.baselineDiff === null) foot.updateBaseline(diff);

      foot.updateBaseline(diff);

      if (foot.state === 'waiting' && diff > foot.baselineDiff + MIN_ANGLE_DIFF) {
        foot.state = 'extended';
        foot.maxDiff = diff;
      } else if (foot.state === 'extended') {
        if (diff > foot.maxDiff) foot.maxDiff = diff;
        if (diff < foot.maxDiff * PEAK_DROP_RATIO) {
          indicateKick(side);
          // Kick detection indicated (WebRTC removed)
          foot.triggerCooldown();
          foot.state = 'retracting';
        }
      } else if (foot.state === 'retracting' && diff < foot.baselineDiff + MIN_ANGLE_DIFF / 2) {
        foot.state = 'waiting';
      }
    }

    function indicateKick(side) {
      ctx.fillStyle = side === 'Left' ? 'red' : 'blue';
      ctx.font = 'bold 30px Arial';
      ctx.textAlign = side === 'Left' ? 'left' : 'right';
      ctx.textBaseline = 'top';
      ctx.fillText(`${side} Kick!`, side === 'Left' ? 10 : canvas.width - 10, 10);

      // Send kick data over the data channel
      if (dc && dc.readyState === 'open') {
        const kickEvent = side === 'Left' ? "left_kick" : "right_kick";
        dc.send(kickEvent);
      }
    }

    function drawSkeleton(pose, scaleX, scaleY) {
      ctx.strokeStyle = 'green';
      ctx.lineWidth = 3;
      connections.forEach(([kp1, kp2]) => {
        const keypoint1 = pose.keypoints.find(kp => kp.name === kp1);
        const keypoint2 = pose.keypoints.find(kp => kp.name === kp2);
        if (keypoint1 && keypoint2 && keypoint1.score > 0.3 && keypoint2.score > 0.3) {
          ctx.beginPath();
          ctx.moveTo(keypoint1.x * scaleX, keypoint1.y * scaleY);
          ctx.lineTo(keypoint2.x * scaleX, keypoint2.y * scaleY);
          ctx.stroke();
        }
      });
    }

    function drawKeypoints(pose, scaleX, scaleY) {
      for (const keypoint of pose.keypoints) {
        if (keypoint.score > 0.3) {
          ctx.font = 'bold 7px Arial';
          ctx.beginPath();
          ctx.arc(keypoint.x * scaleX, keypoint.y * scaleY, 5, 0, 2 * Math.PI);
          ctx.fillStyle = 'red';
          ctx.fill();
          ctx.fillStyle = 'white';
          ctx.fillText(keypoint.name, keypoint.x * scaleX + 6, keypoint.y * scaleY + 2);
        }
      }
    }

    let pc = null;
    let dc = null;

    function compressSDP(desc) {
        const json = JSON.stringify(desc);
        const compressed = pako.deflate(json, { to: 'string' });
        return encodeURIComponent(btoa(String.fromCharCode.apply(null, compressed))); // Ensure URL-safe encoding
    }

    function decompressSDP(str) {
        try {
            const decodedStr = decodeURIComponent(str); // Fix URL encoding issue
            return JSON.parse(pako.inflate(Uint8Array.from(atob(decodedStr), c => c.charCodeAt(0)), { to: 'string' }));
        } catch (error) {
            console.error("Error decoding SDP:", error);
            return null;
        }
    }

    function getQueryParam(name) {
        return new URLSearchParams(window.location.search).get(name);
    }

    function updateShareableURL(param, value) {
        const url = new URL(window.location.href);
        url.search = `?${param}=${value}`;
        document.getElementById('shareableUrl').value = url.toString();
    }

    document.getElementById('copyUrlButton').addEventListener('click', function() {
      const shareableUrl = document.getElementById('shareableUrl');
      shareableUrl.select();
      shareableUrl.setSelectionRange(0, 99999); // For mobile devices
      document.execCommand('copy');
      alert('URL copied to clipboard!'); // Optional: provide feedback
    });

    async function startWebRTC() {
      const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
      pc = new RTCPeerConnection(configuration);

      pc.onicecandidate = e => {
          if (!e.candidate) {
              const compressed = compressSDP(pc.localDescription);
              const receiverUrl = `${window.location.origin}/receiver.html?offer=${compressed}`;
              updateShareableURL('offer', receiverUrl);
              console.log("Share this offer URL:", receiverUrl);
          }
      };

      pc.onconnectionstatechange = () => {
          if (pc.connectionState === 'connected') {
              console.log("âœ… Connection established!");
          }
      };

      dc = pc.createDataChannel("kick-channel");
      dc.onopen = () => console.log("Data channel opened");
      dc.onmessage = e => console.log("Message from receiver: " + e.data);

      const offerDesc = await pc.createOffer();
      await pc.setLocalDescription(offerDesc);

      // Retriever Mode (if offer is present in the URL)
      const offer = getQueryParam('offer');
      if (offer) {
          console.log("ðŸŸ¡ Retriever mode: Received offer, generating answer...");
          const offerDesc = decompressSDP(offer);
          await pc.setRemoteDescription(offerDesc);

          const answerDesc = await pc.createAnswer();
          await pc.setLocalDescription(answerDesc);
          const compressedAnswer = compressSDP(answerDesc);
          updateShareableURL('answer', compressedAnswer);
          console.log("ðŸŸ¡ Answer generated. Share this answer URL:", window.location.href);
      }
    }

    async function init() {
      video = document.getElementById('video');
      canvas = document.getElementById('overlay');
      ctx = canvas.getContext('2d');
      video.srcObject = await navigator.mediaDevices.getUserMedia({video: true});
      await new Promise(r => video.onloadedmetadata = () => { video.play(); r(); });

      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet);
      statusEl.textContent = 'Detection Started';

      await startWebRTC();
      detect();
    }

    async function detect() {
      requestAnimationFrame(detect);
      const poses = await detector.estimatePoses(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (!poses[0]) return;
      const pose = poses[0];
      const kpMap = {};
      pose.keypoints.forEach(kp => { kpMap[kp.name] = kp; });
      const scaleX = canvas.width / video.videoWidth;
      const scaleY = canvas.height / video.videoHeight;
      drawSkeleton(pose, scaleX, scaleY);
      drawKeypoints(pose, scaleX, scaleY);
      const vRef = verticalRef(pose);

      detectKick(leftFoot, kpMap['left_hip'], kpMap['left_ankle'], vRef, 'Left');
      detectKick(rightFoot, kpMap['right_hip'], kpMap['right_ankle'], vRef, 'Right');
    }

    window.onload = init;
  </script>
</body>
</html>