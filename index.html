<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pose Detection Test</title>
  <!-- TensorFlow.js and Pose Detection libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

  <style>
    body {
      margin: 0; 
      padding: 0;
      text-align: center;
      background: #f3f3f3;
      font-family: sans-serif;
    }
    #videoContainer {
      position: relative;
      display: inline-block;
    }
    video, canvas {
      width: 640px;  /* Adjust as you like */
      height: 480px; /* Adjust as you like */
      border: 1px solid #aaa;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    #status {
      margin: 10px 0;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Continuous Pose Detection (MoveNet)</h1>
  <p id="status">Loading model...</p>

  <div id="videoContainer">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <script>
    let video, canvas, ctx;
    let detector;
    let animationId;

    const statusEl = document.getElementById('status');

    // List of edges to connect keypoints into a skeleton
    const connections = [
      ['nose', 'left_eye'], ['nose', 'right_eye'],
      ['left_eye', 'left_ear'], ['right_eye', 'right_ear'],
      ['nose', 'left_shoulder'], ['nose', 'right_shoulder'],
      ['left_shoulder', 'left_elbow'], ['right_shoulder', 'right_elbow'],
      ['left_elbow', 'left_wrist'], ['right_elbow', 'right_wrist'],
      ['left_shoulder', 'right_shoulder'],
      ['left_shoulder', 'left_hip'], ['right_shoulder', 'right_hip'],
      ['left_hip', 'right_hip'],
      ['left_hip', 'left_knee'], ['right_hip', 'right_knee'],
      ['left_knee', 'left_ankle'], ['right_knee', 'right_ankle']
    ];

    async function init() {
      // Grab elements
      video = document.getElementById('video');
      canvas = document.getElementById('overlay');
      ctx = canvas.getContext('2d');

      // 1) Setup camera
      await setupCamera();

      // 2) Create the MoveNet detector
      statusEl.textContent = 'Loading MoveNet model...';
      const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
      statusEl.textContent = 'Model loaded! Starting detection...';

      // 3) Start the detection loop
      detectPose();
    }

    async function setupCamera() {
      // Request webcam
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: 640, height: 480 },
        audio: false
      });
      video.srcObject = stream;

      // Wait for the video to be ready
      return new Promise(resolve => {
        video.onloadedmetadata = () => {
          video.play();
          // Match canvas to video size
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          resolve();
        };
      });
    }

    async function detectPose() {
      // The main detection + draw loop
      animationId = requestAnimationFrame(detectPose);

      if (!detector) return;
      if (video.readyState < 2) return; // not fully playing

      try {
        // Estimate poses
        const poses = await detector.estimatePoses(video);

        // Draw video onto canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // Draw the detected pose(s)
        if (poses && poses.length > 0) {
          drawPoses(poses);
        }
      } catch (err) {
        console.error('Pose estimation error:', err);
      }
    }

    function drawPoses(poses) {
      for (const pose of poses) {
        // Draw keypoints
        for (const keypoint of pose.keypoints) {
          if (keypoint.score > 0.3) {
            // Draw a small circle
            ctx.beginPath();
            ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();

            // Optionally label each keypoint
            ctx.fillStyle = 'white';
            ctx.fillText(keypoint.name, keypoint.x + 6, keypoint.y + 2);
          }
        }
        // Draw skeleton
        drawSkeleton(pose);
      }
    }

    function drawSkeleton(pose) {
      // Build a map from name->keypoint
      const kpMap = {};
      pose.keypoints.forEach(kp => {
        kpMap[kp.name] = kp;
      });

      ctx.strokeStyle = 'green';
      ctx.lineWidth = 3;

      // Draw each connection
      for (const [kp1, kp2] of connections) {
        const keypoint1 = kpMap[kp1];
        const keypoint2 = kpMap[kp2];
        if (keypoint1 && keypoint2 &&
            keypoint1.score > 0.3 && keypoint2.score > 0.3) {
          ctx.beginPath();
          ctx.moveTo(keypoint1.x, keypoint1.y);
          ctx.lineTo(keypoint2.x, keypoint2.y);
          ctx.stroke();
        }
      }
    }

    // Initialize on page load
    window.onload = init;
  </script>
</body>
</html>
