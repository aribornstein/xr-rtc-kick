<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kick Detector and Visualizer - Receiver</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
    }
    textarea {
      width: 100%;
      margin-bottom: 10px;
    }
    button {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2>Receiver (Responder)</h2>
    <button id="startButton">Initialize WebRTC</button>
    <br>
    <label for="signalingData">Paste signaling data from Initiator (Offer/ICE):</label>
    <textarea id="signalingData" rows="8" placeholder='{"sdp":{...}} or {"candidate":{...}}'></textarea>
    <br>
    <button id="connectButton">Connect</button>
    <br>
    <label for="localAnswer">Local Answer (send this back to Initiator):</label>
    <textarea id="localAnswer" rows="8" readonly></textarea>
    <br>
    <label for="localICE">Local ICE Candidates (send these to Initiator):</label>
    <textarea id="localICE" rows="8" readonly></textarea>
  </div>

  <!-- Three.js for stick figure visualization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

  <script>
    let scene, camera, renderer, stickFigure, peerConnection, dataChannel;

    // Initialize Three.js scene
    function initThreeJS() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create stick figure
      stickFigure = createStickFigure();
      scene.add(stickFigure);

      animate();
    }

    // Create a simple stick figure using lines
    function createStickFigure() {
      const material = new THREE.LineBasicMaterial({ color: 0x0000ff });

      // Define points for the stick figure
      const head = new THREE.Vector3(0, 1, 0);
      const neck = new THREE.Vector3(0, 0.5, 0);
      const torso = new THREE.Vector3(0, 0, 0);
      const leftLegStart = new THREE.Vector3(0, 0, 0);
      const leftLegEnd = new THREE.Vector3(-0.5, -1, 0);
      const rightLegStart = new THREE.Vector3(0, 0, 0);
      const rightLegEnd = new THREE.Vector3(0.5, -1, 0);
      const leftArmStart = new THREE.Vector3(-0.5, 0.5, 0);
      const leftArmEnd = new THREE.Vector3(-1, 0, 0);
      const rightArmStart = new THREE.Vector3(0.5, 0.5, 0);
      const rightArmEnd = new THREE.Vector3(1, 0, 0);

      // Create geometries for each limb
      const headGeometry = new THREE.BufferGeometry().setFromPoints([head, neck]);
      const torsoGeometry = new THREE.BufferGeometry().setFromPoints([neck, torso]);
      const leftLegGeometry = new THREE.BufferGeometry().setFromPoints([leftLegStart, leftLegEnd]);
      const rightLegGeometry = new THREE.BufferGeometry().setFromPoints([rightLegStart, rightLegEnd]);
      const leftArmGeometry = new THREE.BufferGeometry().setFromPoints([leftArmStart, leftArmEnd]);
      const rightArmGeometry = new THREE.BufferGeometry().setFromPoints([rightArmStart, rightArmEnd]);
      
      // Create lines for each limb
      const headLine = new THREE.Line(headGeometry, material);
      const torsoLine = new THREE.Line(torsoGeometry, material);
      const leftLeg = new THREE.Line(leftLegGeometry, material);
      const rightLeg = new THREE.Line(rightLegGeometry, material);
      const leftArm =  new THREE.Line(leftArmGeometry, material);
      const rightArm = new THREE.Line(rightArmGeometry, material);

      // Create a group and add the limbs to it
      const stickFigureGroup = new THREE.Group();
      stickFigureGroup.add(headLine);
      stickFigureGroup.add(torsoLine);
      stickFigureGroup.add(leftLeg);
      stickFigureGroup.add(rightLeg);
      stickFigureGroup.add(leftArm);
      stickFigureGroup.add(rightArm);

      // Store references to the legs for animation
      stickFigureGroup.leftLeg = leftLeg;
      stickFigureGroup.rightLeg = rightLeg;

      return stickFigureGroup;
    }

    // Animate the scene
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // Initialize WebRTC as receiver (responder)
    function initWebRTC() {
      peerConnection = new RTCPeerConnection();

      // Listen for incoming data channels (from initiator)
      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        dataChannel.onopen = () => console.log("Data channel opened");
        dataChannel.onmessage = (event) => handleKickData(JSON.parse(event.data));
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          const localICETextarea = document.getElementById("localICE");
          localICETextarea.value += JSON.stringify(event.candidate) + "\n";
          console.log("Local ICE candidate:", event.candidate);
        }
      };
    }

    // Decompress from a Base36 string back to the original object.
    function decompressSignaling(base36Str) {
        let chars = [];
        // Each char code was padded to 2 digits
        for (let i = 0; i < base36Str.length; i += 2) {
            const code = parseInt(base36Str.substr(i, 2), 36);
            chars.push(String.fromCharCode(code));
        }
        const decompressed = LZString.decompressFromUTF16(chars.join(''));
        return JSON.parse(decompressed);
    }

    // Add this helper function for compressing signaling data.
    function compressSignaling(data) {
        const json = JSON.stringify(data);
        const compressed = LZString.compressToUTF16(json);
        let base36Str = "";
        for (let i = 0; i < compressed.length; i++) {
            const hex = compressed.charCodeAt(i).toString(16).padStart(2, '0');
            const num = parseInt(hex, 16);
            base36Str += num.toString(36);
        }
        return base36Str;
    }

    // Process received kick data and animate stick figure
    function handleKickData(data) {
      console.log("Received kick data:", data);
      const kickRotation = Math.PI / 4; // Define kick rotation amount

      if (data.type === "left_kick") {
        // Rotate left leg for left kick
        stickFigure.leftLeg.rotation.x = kickRotation;
      } else if (data.type === "right_kick") {
        // Rotate right leg for right kick
        stickFigure.rightLeg.rotation.x = -kickRotation;
      }

      // Reset rotation after a short delay
      setTimeout(() => {
        stickFigure.leftLeg.rotation.x = 0;
        stickFigure.rightLeg.rotation.x = 0;
      }, 500);
    }

    // Event listeners for UI buttons
    document.getElementById("startButton").addEventListener("click", () => {
      initWebRTC();
    });

    document.getElementById("connectButton").addEventListener("click", () => {
      let signalingText = document.getElementById("signalingData").value.trim();
      if (signalingText) {
        try {
          // Check if the input starts like a JSON object or array.
          if (!(signalingText.startsWith('{') || signalingText.startsWith('['))) {
            throw new Error("Input does not start with a valid JSON character.");
          }
          const data = JSON.parse(signalingText);
          if (!data || (typeof data !== 'object')) {
            console.error("Signaling data is not a valid JSON object:", signalingText);
            alert("Invalid signaling data: Not a JSON object.");
            return;
          }

          if (data.sdp) {
            // Decompress the SDP from the compressed Base36 string
            const decompressedSDP = decompressSignaling(data.sdp);
            peerConnection.setRemoteDescription(new RTCSessionDescription({
                type: decompressedSDP.type, // Use the decompressed 'type'
                sdp: decompressedSDP.sdp    // Use the decompressed 'sdp'
              }))
              .then(() => {
                console.log("Remote SDP set");
                if (decompressedSDP.type === "offer") {
                  // Create an answer to the offer
                  return peerConnection.createAnswer();
                }
              })
              .then(answer => {
                if (answer) {
                  return peerConnection.setLocalDescription(answer).then(() => {
                    // Compress the answer before outputting
                    document.getElementById("localAnswer").value = compressSignaling(peerConnection.localDescription);
                    console.log("Answer created:", peerConnection.localDescription);
                  });
                }
              })
              .catch(console.error);
          } else if (data.candidate) {
            // Add received ICE candidate
            peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate))
              .then(() => console.log("Added remote ICE candidate"))
              .catch(console.error);
          } else {
            console.error("Signaling data missing 'sdp' or 'candidate' property:", data);
            alert("Invalid signaling data: Missing 'sdp' or 'candidate'.");
          }
        } catch (error) {
          console.error("Error parsing signaling data:", error, "Input:", signalingText);
          alert("Invalid signaling data format: " + error.message);
        }
      }
    });

    // Initialize Three.js on page load
    window.onload = initThreeJS;
  </script>
</body>
</html>
